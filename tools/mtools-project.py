#!/usr/bin/env python
#
# Copyright 2015 Arvind Singh 
# This file is part of the mtools library.
#
# mtools is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with mtools  If not, see <http://www.gnu.org/licenses/>.


############################################################################
#                                                                          #
#              script: create an empty mtools project.                     #
#                                                                          #
############################################################################



################### main.cpp ####################

mainFile = r"""/***********************************************
 * project: [PROJECT_NAME_PLH]
 * date: [PROJECT_DATE_PLH]
 ***********************************************/

#include "mtools/mtools.hpp" 


int main(int argc, char *argv[]) 
    {
    MTOOLS_SWAP_THREADS(argc,argv); // required on OSX, does nothing on Linux/Windows
    mtools::parseCommandLine(argc,argv,true); // parse the command line, interactive mode
	
    mtools::cout << "Hello World\n"; 
    mtools::cout.getKey();	
    return 0;
    }
	
/* end of file main.cpp */
"""

################### CMakeLists.txt ####################


cmakeFile = r"""################################################
# CMakeLists for project: [PROJECT_NAME_PLH]
# date: [PROJECT_DATE_PLH]
#
# generated by mtools-project.py
################################################

cmake_minimum_required(VERSION 3.10.1)

if( WIN32 )
	# look for vcpkg on windows
	if (DEFINED ENV{VCPKG_DIR})
		string(REPLACE "\\" "/" _vcpkg_dir "$ENV{VCPKG_DIR}")
	else ()
		find_file( _vcpkg_exe "vcpkg.exe" PATHS ENV PATH)
		if (_vcpkg_exe)			
			get_filename_component(_vcpkg_dir ${_vcpkg_exe} DIRECTORY)
		endif()		
	endif()	
	if (_vcpkg_dir)	
		set(CMAKE_TOOLCHAIN_FILE "${_vcpkg_dir}/scripts/buildsystems/vcpkg.cmake")					
		message(STATUS "Windows: vcpkg found at [${_vcpkg_dir}]")	
	else()
		message(STATUS "Windows: vcpkg not found.")	
	endif()
	
    # only Debug and Release configurations
    SET(CMAKE_CONFIGURATION_TYPES "Debug;Release;RelWithDebInfo" CACHE STRING "" FORCE)
	
endif()

# use the same compilers as that used for compiling mtools
set(CMAKE_CXX_COMPILER "${MTOOLS_CXX_COMPILER}" CACHE STRING "" FORCE)
set(CMAKE_C_COMPILER "${MTOOLS_C_COMPILER}" CACHE STRING "" FORCE)

project([PROJECT_NAME_PLH])

# release is the default build type
if (NOT CMAKE_BUILD_TYPE)
	set(CMAKE_BUILD_TYPE Release)
endif ()


find_package(mtools REQUIRED)

file(GLOB project_SRC "*.cpp" "*.hpp" "*.h")

add_executable("${PROJECT_NAME}" ${project_SRC})

target_link_libraries("${PROJECT_NAME}" mtools)


# compile options
if(WIN32)
	set(CMAKE_CXX_STANDARD 17)
	set(CMAKE_CXX_STANDARD_REQUIRED ON)
	set(CMAKE_CXX_EXTENSIONS OFF)
	set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /DMTOOLS_DEBUG_FLAG")	
	# hack for RelWithDebINfo configuration otherwise compile never ends on MSVC
	set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "/Zi /Gm- /Ox /Ob0 /DMTOOLS_DEBUG_FLAG")	
else()
	target_compile_options("${PROJECT_NAME}" PUBLIC "-std=c++17")
	set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -DMTOOLS_DEBUG_FLAG -Wall")
	set(CMAKE_CXX_FLAGS_RELWITHDEBINFO "${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -DMTOOLS_DEBUG_FLAG -Wall")
	set(CMAKE_CXX_FLAGS_RELEASE  "${CMAKE_CXX_FLAGS_RELEASE} -Wall")
endif()


#### external dependencies ####

# add here other dependencies such as:
#    find_package(GSL)
#    target_link_libraries("${PROJECT_NAME}" GSL::gsl)

###############################


# set the project as the default startup project in visual studio.
set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT "${PROJECT_NAME}")

# move CMake specific project inside filter "CMakePredefinedTargets".
set_property(GLOBAL PROPERTY USE_FOLDERS ON)
set(PREDEFINED_TARGETS_FOLDER "CustomTargets")

message(STATUS "")
message(STATUS "")
if (NOT WIN32)
	message(STATUS "Project ${PROJECT_NAME} created for make with configuration ${CMAKE_BUILD_TYPE}")
	message(STATUS "    - Debug : [${CMAKE_CXX_FLAGS_DEBUG}]")
	message(STATUS "    - RelWithDebInfo : [${CMAKE_CXX_FLAGS_RELWITHDEBINFO}]")
	message(STATUS "    - Release : [${CMAKE_CXX_FLAGS_RELEASE}]")
else()
	message(STATUS "Project ${PROJECT_NAME} created for MSVC with configurations")
	message(STATUS "    - Debug : [${CMAKE_CXX_FLAGS_DEBUG}]")
	message(STATUS "    - RelWithDebInfo : [${CMAKE_CXX_FLAGS_RELWITHDEBINFO}]")
	message(STATUS "    - Release : [${CMAKE_CXX_FLAGS_RELEASE}]")
endif()
message(STATUS "")
message(STATUS "")

#end of file

"""


################### clean_build.py ####################

cleanbuildFile = r"""#!/usr/bin/env python
#
# project: [PROJECT_NAME_PLH]
# date: [PROJECT_DATE_PLH]
# script that cleans the /build sub-directory
#

import shutil
import os
#import time 

abspath = os.path.abspath(__file__)
dname = os.path.dirname(abspath)
os.chdir(dname)

if (os.path.isdir("build")):
    shutil.rmtree('build')
#    time.sleep(1)

os.makedirs('build')

with open('build/build_directory','w') as out:
    out.write('This directory (will) contain the CMake generated project files.')

"""


################### run_cmake.py ####################

runcmakeFile = r"""#!/usr/bin/env python
#
# project: [PROJECT_NAME_PLH]
# date: [PROJECT_DATE_PLH]
# Invoque cmake to build the project.
# usage: ./run_cmake [CMAKE_OPTIONS...]
#

import sys
import os
import subprocess

carg = sys.argv
del carg[0]
carg.insert(0,'cmake');
carg.append('..');

# on windows, we build x64 binaries
if sys.platform.startswith('win32'):
	carg.insert(1,'-A');
	carg.insert(2,'x64');

# invoque cmake with the correct arguments
if (not os.path.exists('build')):
	os.makedirs('build')
	

abspath = os.path.abspath(__file__)
dname = os.path.dirname(abspath)
os.chdir(dname + "/build")
subprocess.call(carg)

"""

	

############################################################################
# the python script

import os
import shutil
import sys
import datetime
import subprocess


# Python 2 and 3:
from builtins import input

myinput = input
	
	
# display an error msg
def error(msg):
	print("*** ERROR ***")
	print(msg)
	raw_input("Press Enter to continue...")
	sys.exit(0)
	
	
# make replacement in string then save the file
def repl(str,filename):
	str = str.replace("[PROJECT_NAME_PLH]",project_name)
	str = str.replace("[PROJECT_DATE_PLH]",project_date)
	filepath = project_dir + "/" + filename
	try:	
		fout = open(filepath,"w")
		fout.write(str);
		fout.close()
	except:
		error("cannot write file [" + filepath + "]")	

		
# get the date
project_date = str(datetime.date.today())	
		
# get the project name		
if (len(sys.argv) > 1):
	project_name = sys.argv[1]
else:
	project_name = myinput("Name of the project to create ? ") 

# create the project directory
project_dir  = os.getcwd() + "/" + project_name
project_build = project_dir + "/build"

if os.path.exists(project_dir):
	error("directory [" + project_dir + "] already exist")
try:	
	os.makedirs(project_dir)
except:
	error("cannot create project directory [" + project_dir + "]")	
	
# copy the files		
repl(mainFile,"main.cpp")
repl(cmakeFile,"CMakeLists.txt")
repl(runcmakeFile,"run_cmake.py")
repl(cleanbuildFile,"clean_build.py")

os.chdir(project_dir)
os.system("python clean_build.py")

# uncomment below to run cmake right way.  
#os.system("python run_cmake.py")

print("\n*** Project " + project_name + " created ! ***")

if sys.platform.startswith('win32'):
	myinput("Press Enter to continue...")

# end of script mtools-project.py
############################################################################








