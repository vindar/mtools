#include "stdafx_test.h"

#include "mtools.hpp"


using namespace mtools;




namespace mtools
	{

	namespace internals_rstartree
		{

		/* type representing a position */
		template<size_t DIM, typename TFloat> using Pos = mtools::Vec<TFloat, DIM>;


		/* type representing a minimal bounding rectangle */
		template<size_t DIM, typename TFloat> using MBR = mtools::Box<TFloat, DIM>;  


		/* base stucture for an element of the tree */
		template<size_t DIM, uint32 MAXFILL, typename TFloat> struct RTreeBase
			{
			uint32			nbchildren;			// number of children
			uint32			indexinfather;		// index of this node in its father's children list.
			RTreeBase*		father;				// pointer to the father
			MBR<DIM,TFloat>	mbrs[MAXFILL];		// MBRs of children
			};


		/* structure for a node */
		template<size_t DIM, uint32 MAXFILL, typename TFloat> struct RTreeNode : public RTreeBase<DIM,MAXFILL,TFloat>
			{
			RTreeBase* sons[MAXFILL];		// pointers to the children of the node
			};


		/* structure for a leaf */
		template<typename T, size_t DIM, uint32 MAXFILL, typename TFloat> struct RTreeLeaf : public RTreeBase<DIM,MAXFILL,TFloat>
			{
			T data[MAXFILL];				// data associated with the children
			};


		/* default delete function, return true */
		template<typename T, size_t DIM, typename TFloat> inline bool defaultDeleteFun(const T & obj, const MBR<DIM,TFloat> & mbr) { return true; }


		/* return the distance between a point and a filled mbr
		  ie it is zero if the point is contained in the mbr */
		template<size_t DIM, typename TFloat> inline TFloat SqrDistPosMBR(const Pos<DIM, TFloat> & pos, const MBR<DIM, TFloat> & mbr)
			{
			TFloat d2 = 0;
			for (size_t d = 0; d < DIM; d++)
				{
				auto a = mbr.min[d] - pos[d]; 
				if (a > 0) { d2 += a*a; }
				else
					{ 
					auto b = pos[d] - mbr.max[d];
					if (b > 0) { d2 += b*b; }
					}
				}
			return d2;
			}

		/* default distance from a point to an object: return the distance from the point to the filled MBR.
		(i.e. 0 if the pos is contained in mbr) */
		template<typename T, size_t DIM, typename TFloat> inline TFloat defaultSqrDistFun(const Pos<DIM,TFloat> & pos, const T & obj, const MBR<DIM, TFloat> & mbr) { return SqrDistPosMBR<DIM,TFloat>(pos,mbr); }

		}






	template<typename T, size_t DIM, uint32 MINFILL = 5, uint32 MAXFILL = 12, typename TFloat = double> class RStarTree
		{


		public:

			typedef mtools::internals_rstartree::Pos<DIM,TFloat>	Pos;	
			typedef mtools::internals_rstartree::MBR<DIM, TFloat>	MBR;  
			typedef mtools::internals_rstartree::RTreeBase<DIM, MAXFILL, TFloat>		RTreeBase;
			typedef mtools::internals_rstartree::RTreeBase<DIM, MAXFILL, TFloat>*		pRTreeBase;
			typedef mtools::internals_rstartree::RTreeNode<DIM, MAXFILL, TFloat>		RTreeNode;
			typedef mtools::internals_rstartree::RTreeNode<DIM, MAXFILL, TFloat>*		pRTreeNode;
			typedef mtools::internals_rstartree::RTreeLeaf<T, DIM, MAXFILL, TFloat>		RTreeLeaf;
			typedef mtools::internals_rstartree::RTreeLeaf<T, DIM, MAXFILL, TFloat>*	pRTreeLeaf;


			/**
			 * Constructor.
			 *
			 * @param	callDtors	true to call the destructors when deleting objects (default).
			 **/
			RStarTree(bool callDtors = true) : _size(0), _depth(0), _root((pRTreeBase)nullptr), _globalMBR(), _callDtors(callDtors)
				{
				}


			/**
			 * Move Constructor.
			 **/
			RStarTree(RStarTree && otree) : _size(otree._size), _depth(otree.depth), _root(otree._root), _globalMBR(otree._globalMBR), _callDtors(otree._callDtors), _poolLeaf(std::move(otree._poolLeaf)), _poolNode(std::move(otree._poolNode))
				{
				_size = 0;
				_depth = 0;
				_root = (pRTreeBase)nullptr;
				_globalMBR = MBR();
				_callDtors = false;
				}


			/**
			* Constructor. Loads the tree from a file
			*
			* @param   filename    Filename of the file.
			**/
			RStarTree(const std::string & filename) : _size(0), _depth(0), _root((pRTreeBase)nullptr), _globalMBR(), _callDtors(true)
				{
				load(filename);
				}


			/**
			* Constructor. Loads the tree from a file
			*
			* @param   filename    Filename of the file.
			**/
			RStarTree(const char * str) : _size(0), _depth(0), _root((pRTreeBase)nullptr), _globalMBR(), _callDtors(true)
				{ // ctor needed together with the std::string ctor to prevent implicit conversion to bool and call of the wrong ctor.
				load(std::string(str));
				}


			/**
			* Destructor.
			**/
			~RStarTree()
				{
				reset();
				}


			/**
			 * Return the number of objects inside the tree.
			 **/
			size_t size() const { return _size; }


			/**
			* Return the depth of the tree. (0 if empty, 1 if the root is a leaf...)
			**/
			size_t depth() const { return _depth; }


			/**
			 * Return the global MBR enclosing all the objects in the tree.
			 *
			 * @return	The global MBR for the whole tree or a completely empty rectangle if the tree is empty.
			 **/
			MBR globalMBR() const { return _globalMBR; }


			/**
			* Resets the tree to its initial empty state.
			* Call the destructor of all the T objects if the flag callDtors is set.
			**/
			void reset()
				{
				_size = 0;
				_depth = 0;
				_root = (pRTreeBase)nullptr;
				_globalMBR = MBR();
				_poolNode.deallocateAll();
				if (_callDtors) { _poolLeaf.destroyAndDeallocateAll(); }
				else { _poolLeaf.deallocateAll(); }
				}


			/**
			* Serializes the tree into an OBaseArchive. If T implement a serialize method recognized by
			* OBaseArchive, it is used for serialization otherwise OBaseArchive uses its default serialization
			* method (which correspond to a basic memcpy() of the object memory).
			*
			* @param [in,out]  ar  The archive object to serialise the tree into.
			* @sa  class OBaseArchive, class IBaseArchive
			**/
			void serialize(OBaseArchive & ar) const
				{
				MTOOLS_ERROR("Not yet implemented");		// TODO
				}


			/**
			* Deserializes the tree from an IBaseArchive. If T has a constructor of the form T(IBaseArchive &), it
			* is used for deserializing the T objects in the tree. Otherwise, if T implements one of the
			* serialize methods recognized by IBaseArchive, the objects in the tree are first position/default
			* constructed and then deserialized using those methods. If no specific deserialization method
			* is found, IBaseArchive falls back to its default derialization method.
			*
			* If the tree is non-empty, it is first reset, possibly calling the ctor of the existing T
			* objects depending on the status of the callCtor flag.
			*
			* @param [in,out]  ar  The archive to deserialize the tree from.
			* @sa  class OBaseArchive, class IBaseArchive
			**/
			void deserialize(IBaseArchive & ar)
				{
				MTOOLS_ERROR("Not yet implemented");		// TODO
				}


			/**
			* Saves the tree into a file (using the archive format). The file is compressed if it ends
			* with the extension ".gz", ".gzip" or ".z".
			*
			* The method simply call serialize() to create the archive file.
			*
			* @param   filename    The filename to save.
			* @return  true on success, false on failure.
			* @sa  load, serialize, deserialize, class OBaseArchive, class IBaseArchive
			**/
			bool save(const std::string & filename) const
				{
				try
					{
					OFileArchive ar(filename);
					ar & (*this); // use the serialize method.
					}
				catch (...)
					{
					MTOOLS_DEBUG("Error saving RStarTree object");
					return false;
					}
				return true;
				}


			/**
			* Loads a tree from a file.
			*
			* If the tree is non-empty, it is first reset, possibly calling the dtors of T object depending
			* on the status of the callDtor flag.
			*
			* The method simply call deserialize() to recreate the tree from the archive file.
			*
			* @param   filename    The filename to load.
			* @return  true on success, false on failure [in this case, the lattice is reset].
			* @sa  save, class OBaseArchive, class IBaseArchive
			**/
			bool load(const std::string & filename)
				{
				try
					{
					IFileArchive ar(filename);
					ar & (*this); // use the deserialize method.
					}
				catch (...)
					{
					MTOOLS_DEBUG("Error loading RStarTree object");
					_callDtors = false; reset(); _callDtors = true;
					return false;
					}
				return true;
				}


			/**
			* Check if we should call the destructors of T objects when they are not needed anymore.
			*
			* @return  true if we call the dtors and false otherwise.
			**/
			bool callDtors() const { return _callDtors; }


			/**
			* Set whether we should, from now on, call the destructor of object when they are removed.
			* @param   callDtor    true to call the destructors.
			**/
			void callDtors(bool callDtor) { _callDtors = callDtor; }


			/**
			* Return the memory currently allocated by the tree (in bytes).
			**/
			size_t memoryAllocated() const { return sizeof(*this) + _poolLeaf.footprint() + _poolNode.footprint(); }


			/**
			* Return the memory currently used by the tree (in bytes).
			**/
			size_t memoryUsed() const { return sizeof(*this) + _poolLeaf.used() + _poolNode.used(); }


			/**
			* Returns a string with some information concerning the object.
			*
			* @param   debug   Set this flag to true to enable the debug mode where the whole tree structure
			*                  is written into the string [should not be used for large trees].
			*
			* @return  an info string.
			**/
			std::string toString(bool debug = false) const
				{
				std::string s;
				s += std::string("RStarTree< T =") + typeid(T).name() + " , Dim = " + mtools::toString(DIM) + " , minfill = " + mtools::toString(MINFILL) + " , maxfill = " + mtools::toString(MAXFILL) + " , TFloat = " + typeid(TFloat).name() + " >\n";
				s += std::string(" - Memory : ") + mtools::toStringMemSize(memoryUsed()) + " / " + mtools::toStringMemSize(memoryAllocated()) + "\n";
				s += std::string(" - calling Dtors : ") + mtools::toString(_callDtors) + "\n";
				s += std::string(" - number of objects  : ") + mtools::toString(_size) + "\n";
				s += std::string(" - height of the tree : ") + mtools::toString(_depth) + "\n";
				s += std::string(" - global MBR : ") + mtools::toString(_globalMBR) + "\n";
				if (_root == nullptr) { s += "\n *** Empty tree ! ***\n"; return s; }
				if (!debug) return s;
				s += "\n";
				size_t nbo = 0;
				s +=_printTree(_root, 0,nbo);
				MTOOLS_INSURE(nbo == _size);
				return s;
				}

			
			/* for testing */
			void make()
				{
				_root = _poolNode.allocate();

				pRTreeLeaf leaf1 = _poolLeaf.allocate();
				leaf1->father = _root;
				leaf1->nbchildren = 2;
				leaf1->indexinfather = 0;
				leaf1->mbrs[0] = mtools::Box<TFloat, 2>(-1,2, -3,3);
				leaf1->mbrs[1] = mtools::Box<TFloat, 2>(0, 1, 5, 5);

				pRTreeLeaf leaf2 = _poolLeaf.allocate();
				leaf2->father = _root;
				leaf2->nbchildren = 3;
				leaf2->indexinfather = 1;
				leaf2->mbrs[0] = mtools::Box<TFloat, 2>(1, 1, 1, 1);
				leaf2->mbrs[1] = mtools::Box<TFloat, 2>(2, 4, 3, 3);
				leaf2->mbrs[2] = mtools::Box<TFloat, 2>(-1, 2, 0, 0);

				_root->nbchildren = 2;
				_root->father = nullptr;

				((pRTreeNode)_root)->sons[0] = leaf1;
				_root->mbrs[0] = unionRect(leaf1->mbrs[0], leaf1->mbrs[1]);

				((pRTreeNode)_root)->sons[1] = leaf2;
				_root->mbrs[1] = unionRect(leaf2->mbrs[0], unionRect(leaf2->mbrs[1], leaf2->mbrs[2]));

				_depth = 2;
				_size = 5;
				_globalMBR = unionRect(_root->mbrs[0], _root->mbrs[1]);
				}



			/************ INSERT METHODS *************/

			/**
			 * Insert a new item in the tree with a given mbr. 
			 *
			 * @param	obj	The object to insert
			 * @param	mbr	The associated minimal bounding rectangle. 
			 **/
			void insertItem(const T & obj, const MBR & mbr)
				{
				}


			/**
			* Insert a new item in the tree at a given position. Its mbr is reduced to a point
			*
			* @param	obj	The object to insert
			* @param	pos	The position of the object (i.e. mbr reduced to a point). 
			**/
			void insertItem(const T & obj, const Pos & pos)
				{
				}


			// TODO : add bulk insert method



			/************ DELETE METHODS *************/


			/**
			 * Removes all the item at position pos. 
			 * Only item with mbr reduced to point pos are removed.
			 *
			 * @param	pos	The position of the item to remove (the mbr of the item must match pos exactly). 
			 *
			 * @return	the number of item removed. 
			 **/
			template<typename FUNCTOR> size_t removeItemAtPos(const Pos & pos, FUNCTOR && deletefun = mtools::internals_rstartree::defaultDeleteFun<T,DIM,TFloat>)
				{

				}

			template<typename FUNCTOR> size_t removeItemContaining(const Pos & pos, FUNCTOR && deletefun = mtools::internals_rstartree::defaultDeleteFun<T, DIM, TFloat>)
				{

				}

			template<typename FUNCTOR> size_t removeItemContaining(const MBR & mbr, FUNCTOR && deletefun = mtools::internals_rstartree::defaultDeleteFun<T, DIM, TFloat>)
				{

				}

			template<typename FUNCTOR> size_t removeItemContainedInside(const MBR & mbr, FUNCTOR && deletefun = mtools::internals_rstartree::defaultDeleteFun<T, DIM, TFloat>)
				{

				}

			template<typename FUNCTOR> size_t removeItemIntersecting(const MBR & mbr, FUNCTOR && deletefun = mtools::internals_rstartree::defaultDeleteFun<T, DIM, TFloat>)
				{

				}

			template<typename FUNCTOR> size_t removeAll(FUNCTOR && deletefun = mtools::internals_rstartree::defaultDeleteFun<T, DIM, TFloat>)
				{

				}


			/************ FIND METHODS *************/


			template<typename FUNCTOR> size_t findItemAtPos(const Pos & pos, FUNCTOR && fun)
				{

				}

			template<typename FUNCTOR> size_t findItemContaining(const Pos & pos, FUNCTOR && fun)
				{

				}

			template<typename FUNCTOR> size_t findItemContaining(const MBR & mbr, FUNCTOR && fun)
				{

				}

			template<typename FUNCTOR> size_t findItemContainedInside(const MBR & mbr, FUNCTOR && fun)
				{

				}

			template<typename FUNCTOR> size_t findItemIntersecting(const MBR & mbr, FUNCTOR && fun)
				{

				}

			template<typename FUNCTOR> size_t findAll(FUNCTOR && fun)
				{

				}



			/************ OTHER METHODS *************/


			template<typename FUNCTOR> std::pair<T,MBR> findNearest(const Pos & pos, FUNCTOR && fun = mtools::internals_rstartree::defaultSqrDistFun<T,DIM,TFloat>)
				{

				}




		private:




			/* compute the MBR of all the children of N */
			inline MBR _computeMBR(const pRTreeBase N) const
				{
				if (N->nbchildren == 0) return MBR();
				MBR mbr = N->mbrs[0];
				for (uint32 i = 1; i < N->nbchildren; i++) { mbr = mtools::unionRect(mbr, N->mbrs[i]); }
				return mbr; 
				}



			/* recursive method to print the tree (debug purpose only) */
			std::string _printTree(RTreeBase * N, int depth, size_t & nbo) const
				{
				std::string tab(4*depth, ' ');
				std::string s;
				MTOOLS_INSURE(N != nullptr);
				MTOOLS_INSURE(depth < _depth);
				MBR mbr = _computeMBR(N);				
				if (depth == 0)
					{
					MTOOLS_INSURE(N->father == nullptr);
					MTOOLS_INSURE(mbr == _globalMBR);
					}
				else
					{
					MTOOLS_INSURE(N->father != nullptr);
					MTOOLS_INSURE(N->indexinfather < N->father->nbchildren);
					MTOOLS_INSURE(N->father->mbrs[N->indexinfather] == mbr);
					}					
				if (depth +1 < _depth)
					{ // deal with a node
					MTOOLS_INSURE(_poolNode.isInPool(N));
					RTreeNode * NN = (RTreeNode *)N;
					s += tab + "NODE [" + mtools::toString((uintptr_t)NN) + "]\n";
					s += tab + "- depth = " + mtools::toString(depth) + "]\n";
					s += tab + "- index in father = " + mtools::toString(NN->indexinfather) + "\n";
					s += tab + "- nb children     = " + mtools::toString(NN->nbchildren) + "\n";
					s += tab + "- total MBR       = " + mtools::toString(mbr) + "\n";
					for (uint32 i = 0;i < NN->nbchildren; i++)
						{
						s += tab + "-- child " + mtools::toString(i) + "   MBR = " + mtools::toString(NN->mbrs[i]) + " --> [" + mtools::toString((uintptr_t)NN->sons[i]) + "]\n";
						MTOOLS_INSURE(NN->sons[i] != nullptr);
						MTOOLS_INSURE(NN->sons[i]->father == N);
						}
					s += "\n";
					for (uint32 i = 0;i < NN->nbchildren; i++) { s += _printTree(NN->sons[i], depth + 1, nbo); }
					return s;
					}
				if (depth + 1 == _depth)
					{ // deal with a leaf
					MTOOLS_INSURE(_poolLeaf.isInPool(N));
					RTreeLeaf * LL = (RTreeLeaf *)N;
					s += tab + "LEAF [" + mtools::toString((uintptr_t)LL) + "]\n";
					s += tab + "- depth = " + mtools::toString(depth) + "\n";
					s += tab + "- index in father = " + mtools::toString(LL->indexinfather) + "\n";
					s += tab + "- nb children     = " + mtools::toString(LL->nbchildren) + "\n";
					s += tab + "- total MBR       = " + mtools::toString(mbr) + "\n";
					for (uint32 i = 0; i < LL->nbchildren; i++)
						{
						s += tab + "-- child " + mtools::toString(i) + "   MBR = " + mtools::toString(LL->mbrs[i]) + "\n";
						}
					nbo += LL->nbchildren;
					s += "\n";
					return s;
					}
				MTOOLS_ERROR("DEPTH ERROR!\n");
				return s;
				}



			size_t      _size;		// number of elements in the tree
			size_t      _depth;		// depth of the tree
			pRTreeBase  _root;		// pointer to the root
			MBR         _globalMBR; // global MBR for the whole tree. 

			bool _callDtors;		// should we call the destructors
			SingleObjectAllocator<RTreeLeaf>  _poolLeaf;       // the two memory pools
			SingleObjectAllocator<RTreeNode>  _poolNode;       //


		};



	}









RGBc color(int64 x, int64 y)
	{
	if (x*x + y*y < 10000)
		{
		uint32 c = 1;
		for (int i = 0; i < 100; i++) { c += (x*x) % 100 + (y*y) % 200; }
		c = c % 255;
		return RGBc(c,c,c);
		}
	return RGBc::c_TransparentWhite;
	}



std::vector<double> tvv;


MT2004_64 gen(5679); // RNG with 2M vertices.




RGBc getColor(int64 i, int64 j)
	{
	i -= 100;
	j -= 100;
	if (i*i + j*j < 100*100) return RGBc::c_Red;
	return RGBc::c_TransparentWhite;
	}

RGBc getColor2(int64 i, int64 j)
	{
	i += 100;
	j += 100;
	if (i*i + j*j < 100 * 100) return RGBc::c_Green;
	return RGBc::c_TransparentWhite;
	}


const p_char blop[171] = { "169", "23999",
"78DA4D9C09B624BB6D44B7E20DB80FE76141DEFF167C2F5E11F9255BD2AFAECE629218028100EBBFDECF5E6B8C52DBEC6DF5FA7FFF5BEAFFD47F7D8DB24B5F7D",
"AD7A776B7F9F8F7FB3B63A6EE9678CD94F2D3B3E6FFF6A69A3B533EADA6D977A2F9FB7FFE9FF6639F7D4DAF769B7DEB17A7CFFFEE3A379CAD8B7D6BAD729F3F7",
"FC5DF66CB5377EA3F19FA5C4E7FBDF186D16FE71D7BAD63A75C6F3E7BF75CFD8759C5D5AB96BB51BDF5FFFFA6C9DA59ECE4FF755F6DFE7E7DF65D9F5F276634D",
"9EB9C7EF3973D57DCEBDB5B5BEEF1DE3F7BBE7AE59EFBAB3AC71FAFCED4FFBD7EAEA7DED7E6FEF77B5F3D65F0FAB9BEDF27677AE9BDF1F77EF7D5B77830A8B38",
"BFCF2F7F61AC55666393F9E9F95B67E98DCD67DFD94FB67BBEFDDF63DECE76F12373F1B4FB7BCE62212C72D47907FBDAD6EFF3B3F88CED72E91E577FFBC9BB96",
"CD1F94716F63EFDEF99EDAC6E494F9654EA0FF7DDEFF95E59B6DDE9815AC79F6EFF356F7BC950367E967CCD27EF6537BDDA39C3AF81F3C6FCEF7F97525B71D9E",
"34E7BEF3775ED8011B56EF1CB3AD5ACE8973E1F3B157B998DCAD9D579FFBF7FDC16EB235B3EEBB07BF547FEF85D994393B7F85B79AA3BC75DE86415C3EE78FCF",
"58BFF39AFF1AFBB6F97877EDA87FDF3F7D178D7DE116FDB4F25BBF67B159DFBD77CEDBD6FA3D0713613FA78E51CB9D7DFDCEF19CD14A8F3DE5DC31DFDFF377E1",
"CCDDAF5DCA6ACFAEFABF33BA87B2381AACEACF6E9BE788738E73F803DEEBAC3ADEF379579EBDF869FED65CEFDC31E73D384B4C7996C25F79EF5BC6E1AB9345B2",
"601EF8DE4BAFE3C027DEBA0BBFF6F38B8239B3948A8594EEDFFDF9EF3DEC64E7174B39B8E32ABF732978E2A80482C341B7FBB3F3FBAF97EE8B8D76F08EF6CEEB",
"FCDB78B99EBD6A6763E759BFF5AC56162163B7B5077FB0CE3B5FB6F16057A5F021A77F7E767B47AFFC6C73333A5E3F7EEF3B31724258EDF8DE6AAB3DBF661D7C",
"CD5F5FA5F032E7F7BBA33436933DE39DC6B8E72FCE0CFCF714F60C5F22225ECCE8F7FD63A822A6E05D58E8B34FE212EE4CB42214F2DA04A015CF619F2B168AC3",
"700058523FCF2FD884CAAEF00C0CFBB4B1E3FBE7DFE0357595CA8FB785EFFFFC02CBD04B59552772CC58FF306E0F2D76E0F51EFE3ACF1E7A257A722AC41436E1",
"EE2F0EF3CF441282FDAEC4D2B76F7B8D5EB0ADC3EEF007B3FDBE8F2F2C7DCB507930E0F1E25B27B857035884D7F367B7FBDF1A97432AD553D13FDE390ECC87FF",
"C327D97BE2FFFE7DBE880A84170CF97270A487DFEFF29D3BEFC2BF08DBECCFF3DFC579131077EF38388FDF3F7B203C4E1CA06DC216DB505E9C1C86DA35CD0C78",
"662BEFBDF0288E5093AB5A697F7189E043E0C05430E581373D3FC2C6CBE117780973D57DEBB9440D4C84608CAFB6CFEF76C3108DD08DF32594B5DFF375AE5539",
"007F75F7CF3ED92C9E82537672E79ACFCE0981A4AAE1623691653FBFC3C43C625E899DC038D6EF397B184AF05B56D5575D2F2E11AFB01C727BBFFB62772FAE6E",
"DCC8948A1D9DCD16BE78C8D9E25DE4D763DC6E190F6BC4FDCDCA392F52FFF9D939D6D3C2B135A0B9C64E3F1D84140207AFBA087E3BFD91636A83F0B78829FCD0",
"CBBF7C93B48371B25326DBDF39120526EEC8814C2DFEDCF45F764D23E22097DEF4F681AD241791387956DBF7E53BE23E4BC7318879A49A1F4EC01ECCBB95506F",
"C03DABBD78754978C384BD3D5E76E99D2328864324A662CE60A9F77967193C6236B6BF62762F6E7342A42E318B598060F4ECDF80454CC258F8E95EDF3A354EBC",
"0DC7C01FF9E5F98B0F8021110A680C976453DA8BFF186125E6D661247D79F0FE63B72E0F00981048EB1FFEF1770BDE0C82C3D8C69F0FBCBC439425AFF3CEA713",
"EA77E29CC07B7D98D7B0A4FED6CF4B81D230594C1A2C719E9DF3D7C10DD704CF16FEE5F7F097A26369D14B80D8DFFE0F6C81DC2FCA24AAD4317E764510D68D78",
"064F27453F7CC5F1B2A583E754D2D12DCFFE59337F1B4317925D56F6B36700916EC74E2EDC688EFEEC9335B2BFB89C08ECFCFC883830C9CAC46DE15D6539CFEF",
"08935BF35E047A23DD7B3E2E089E5C20078CD49D7DB8D1A442C8E0F5EA268CD5C47B876307CB60B5E4EBFAD62F30E7A896E649F8FBF951FD67EAE3B8D84C720E",
"DFB8CF5F3008F3506337BB47F7DECB8D066A98C971AFFDF027EBE79FC0E0A51A43F78B63C5E0488ED5F57891967996746D926D878F49402F3EEC6A5C223A71FA",
"98D8ECBFE7B82B854323C31340FA79FECBBB826B5BE4B562667E7895984002E0CD087A98D24D7B6363701F1CF21A525E9DD20C6D4320B2B4E6C4CF7C9F13F0B7",
"7BD407FDF739FEE38371019C0958FFBE0F38C3DD1B4685D599A21F7EE06B377233C68067D61F1E601D85A3E7E0311622CE3B2FF329115E942ED24C7F2445F32F",
"FE0C63B9FB0F2FE9BFEC6CD7195D17A1633E7B9B180941AF9BAA4193FBE15BCE153403FC27FA8BA5333E9B78F0C569F4BEECDE8B6FD880E555D3AD895BAF6EA2",
"C4C2208660DE2CB89F9F56118E209FBD66FDBF38CCF3A906CC253A195F58CFCED92D72B8151C19AECF9F7F89DB5903218C6323B6CEF270CEB6489B7EF70A17FA",
"B34F5D88904BFCC779A9F5DA8B0FEC0031A8F872D53A29F3202B34E9B58802894388480479F061E3FF31AEF13B2FB693630209603DC49BFC5DFFFE715305BFD8",
"61D6658BDD62CF401B544833E312414DB0577433A1EEF8D5B93CBD1967081C82A6FBF2238BB1B60814B8B581B79FC22E7EA1F066FECD97971B81FBAF60ABFAF0",
"7D784CDC6CADB8A7754FFDE57D7EB799984FE4486C74FDD927F1D37289B44E982484CCDBB24E67F1735AB035914ECFE75C9742C49E46F692F502EE4578310750",
"F0BE3AE56ACFC09E8399E24B963D0FE7101444A0ECBFA1EB1727B1379640CAE4D0B029FC62BDB8C11E4CCF6510832C255F7E17FFF3583EA566A8BFFD04876356",
"32041597A4422A59EF0B9DF93B26E5629D9A3850A41C51A88351B37EE18C5A98145F65F7EBC37BC05B5206310E7BC70A13EF1DCB9189ED501C7012EDAD875DAB",
"86C769B23D8FAF68FFB000F0B6EEC2B9D787F3DD7F0ABC6DC16A517C7FF985758A030C1E4431D2F3EF77894B3804D526519A10C1E93C3B04CA58E98AB2D88F9A",
"71865C409589F15C3DB5F4E46DC83524343ED7236FE252C9070C8D00E6E9AEFB70329BD9C520442710EECAF7750796568E7912FF6EFBE17C3DA29138E54478DF",
"F99DCBC09CB54482074691E7C2FB1783CAF05759C17FE20F75251B6F19D1F7FE7002FB7382B020CCD5E7D7454C48A8C22F2C00EAC38D980836CE5EB3248EB8BD",
"7C51E418AEF9545037F2FB4648CA70EB9735E5147EFB4FDA6283384AABB95E7F7571E06D4FEB04B46011E5874F74976ED571B6754F9E630FBAE8480A19924FF2",
"06F81C79199316539EF2BE7F25AFF079F6060B1AFBD529983270D2AA9597E32D5EDCE3A429D346C00810D5ADAF4EE401A033962939776AE6776232511C6303EF",
"CBD3FCCE85C5070FC8E112ECDB7D790717B51624E60D6BF8C40F3A348BA700202DE1942F6F927297C486D9910C7ADE39E246B74B12501B000B9257341D9B26A8",
"4878E392F62678C2B7F13C36C8377838BF99BD4869FC0891A5BD3889BD0A9F2529974920F11B47778D0F041B13F3B343620B7B4394FFDBA1913CA4E8F848CE60",
"2EF5F9C514874B73F2564B332D6FFF056804802B8A20639C87B77151B23D384A12B5EFCC2FB83ED62108955C2267BC3A2240FEB1041B069AB77EAC87439C06D0",
"2EAD555E1C60E984629280887FFDF208764230D9F78849D9A767875BBE881446A025109850D2FEFDFB042199278D2B71DD951124906FB23CA55EF2901C23B18F",
"6009F402768DC75F111730E78107E3EF2BEBCA5E0CDC1897A53186FAE2ADD53B090FA31347ACAFDE777B4C3BFCF734E7BEF53421CE90632293F092AF6E02116D",
"DDF188B7CBC7E758860038A4CF44CBCFEFB6D41EF91B4BEF963B2FEE75F91CF03900DDEA38F3E61FC925112B823BEB9D8BBCA42677239AD7F17026485D0A9BE3",
"3956B53F9C097E63B33C19500A063133AFB95FCBBC53240ECE7879D0736123F02137F6FEFCDD3A771AD670DF5364F9B22ED32E71084091957C7FB88B106C5616",
"3B4A7DEFCFEFCEE4C40738AE882BCE6F9F8745820088B042B4CCFA4EE83FE484C04558447BCF67F17C8B18CF869EFA97975B3C5FCBDD6CBDC1B3FEE258E02EC9",
"10AC08ABC5BE1E3F2FC7036C03E09345AC111EAF88B11A6E6B18D7F3A38E3F6EA98C3B823ADEC9438A9FC95A569404A8D6DF73C89B9453049A30A33FBE573C4C",
"FEC09BDBB13822CFFCF238E7B885552DACEE64FDA8DF61FBF28A3A387FF63E670D0071C24997459DEDF10F6306612AF48D3A22EBFDAAEB5A77B02E22687979CD",
"EA51229F179F26E9B79E05482D328B12386C77F23320260BCBE58AC679B81DCC3C05FF1294AEAD7FBC047623D40B7719F93946C23B039AA40E76FA9759778EE0",
"262DA8D7F9FC940D6081441F804D7B78661A0F4182CD4004BC7BF67608FEB2B47F2CE2BE23FB325D0605CCB20913BBBF38C67B5A4A81C631500BB6577768B0D4",
"008073B0D4A9896FA959C897E41682587BF52FF520D0C163940D96576889AF46705A7F7DA55BDF3EB3B8D1A3D781F7026A1FBFD4645BCEB0FC9285C87C3D03C4",
"587C005CACB7DEFE04AD6AD9D1C50FFBF1B702077C6CFB38C9B0870FA7510D20CB7BDC00648F976BFA21189C4F39FEF2E25BB58AE0F1542B40A6F9C57371D71A",
"98A944D5F77D72F789E682510B93ECC9AB18955879F3D51EBF71ADAF4F30973D9A54EDF92F2767DB6BDB97B02C78EBE797A63C9D2C7FAB0FAF5A9FDA4C24B9E1",
"45323D23FDC894CC72CC47A5F6D7EFA3462B768E80566C52BD89376C4CF21452F2A4483A5FDD2D982696914EC1CC2BF925091719F2164CC07AB8512CC06AB02D",
"8BA6F2E10436058F94C52694CDE437AC1F85743C9B5F18C93B8DB0065E8D7427527EFB5F23318C13FC0F6B4E5C2D94116136E9B192FDAC2BFD4954257454704D",
"D64D9C4B941E3CE4FAE289F70C179C2F380B0B6B2BF91FFB1902088C7FB4179FA95BAD6ED922FB0EBCD55A19E731D90052414CACC787B055CDDC808791D4C67A",
"E74510B1FBB8CC62D101C87E161BC7F7AE288540F9F84FB68B90647B0113BA2F7F597FC9FB5FB1DBB13F567E75846D0B62338B0D383E5FBE9B56E9FE11DFE68F",
"E76787D52C2AF2C4B2F76F9DC47933D79495A5D0C04A5F7CC6F2B4D92B9C11CB66BF35FA2586626985FFF27B723CEC1A4185F479D787EBAA7C26A01D50DA4AF2",
"48921132A818DB06BDBCB8D7ED23D8AC9858D078B885BC2667B20D0154869845E27F62200FA9B60967797C72FD8793535A822A08339EF08BC3D71C4A22059755",
"1BA2995F8EFCC0B627CCE68C93DF2FF6634046D79DDDF3240F2FA1404824B5800613576CDE16072D41A6B16D2FCEE33CE24B9C2068F2F33E2FF6F28C7DDB761A",
"B9FFAB5F4897824D51533BEF7DAD16C84E4120DEF2E267FF1749870463AD4E306B2F1FCDE8ECEF1969793DFF32CF0A4BF0670131BFBB92FFBC56C9647976BAAF",
"3C17ECC36562113802F6FEEA2322C3F227C59A321CF5C7D7D9BAB31DCD6B2DDB7DE977E239FBCE1279FC8FF71CE00671876063BFECF4EC17B7A059ACB9890FFB",
"F51FC96B4187C8894A62D79E786C542514D3DA1A1BEA8F07EEC65FF913A0033E36331E0ADDFE5A63B2B219B7455C23B851DDEEF124E0160ECC12EF442CE8BB66",
"1F597CC8C764478174CDFA91B57036A6530C6365BEBB720638BD85A17FF8FC51B40A7699D1081C25F39D2A0C6CB407657AD33EA550D9B3615DEE3E3F3EB36863",
"24A8829F5A82240EB7B9BEA5A2EC329FBBB34F27AF07CE2732E1006D7D7D16A32D35700D7CF2F8BA19F28DE92E935E46CF7C2A91D755A0C8E7D5F5F80A9BA398",
"AE65C1B06069D947B09D2D8BD582176F5FDF4A5D8A55FC5462F0784EB1CCB56490ACED8F6F673D389C042D95D49552EB1FDF3E7C51B1DAE9E7BFFCCF049205B0",
"66ABB3DF648017EB00D43887569FEEC57C6FA225F8147989B70F96744B42CDDC4B1CADBFF8CC03C46D7C9172903FAEE977D25F20DC2E38B9EBF95D75076CAC99",
"E7DBABDF39177DD14634FE889F261EEB8A347049564902D8FBE597267562E7AD1ADC6E7DFB3FEDD2637E455D841691F1709A9071C46286989FAE0343115134EB",
"69ACE0F160547BD28FECA89DCCECCB2B59B2D1EA82945ABC7C0414206ABACD9B0CF0F56731E52386B00AA2E8497EA09273C5031593B537997852E6C787D4FDD7",
"0DF9F1C9DA49B72F15229195F5B22A221B62E52AFEE92DFBD7404F7F943D188A1A46F637AFCDFA126222B9D1ECFF02AE86CC95DB70922FED2A400C4D00148EF8",
"F75EE4F1E0092D956DEE8DFEF64D5C8B7D630AD7589F75BAA0D456ECB186B41192F5084F5566C5B601E146EA400C23B613A546EB9F4EC07DB0F541DCE498E5E6",
"9E1E80B8BA44DBD740A6C2E8BEF513A6549F6D896F2CAF9FEC832B3992382152ECD77FF4F39093B04D583C29A066FFD7EA3D544996715F9D8BFDB10F247DFE2D",
"93F8F8314C1C3FEABA34ABF9CF7A426061F75D494C7B798D2F361B275B618125D2E3AF5AFCE272351840EACAC4F8369DF90854F7E2BFE7E85FD8B6CF29A9B1E1",
"87AB41C1240B9161D1BBDF7EDA94B7E17743E6F67477F6B98AAD761D9B1F1DD9378FC06F6D835BD8307AF670FF2A203303F6767AE25872BAB084254AB1677C50",
"DEE312A7F599628817072EF621A966EE22C9F5EC8F6BB3DA08DFED23F5518665A2608F5ACD0ECDB387618341CD9A71E9F5A7E4938D3F6C34352B993FFD856427",
"F3239A0C36E0647ED4D96D61F3EFFD745C53BC81EF86F6905738F9B94D3509CE1E78F3C537F22666ABC2816869149BAFCFDE899DF274EA23D461A56EC14030AC",
"15C8AC82885FBCBD6E016E78C4C41CF6DB9FE14B15093EE0D81AA9DB649F411C2BD867199FDC07CB0780CEE852D04F7F489DAB0FA90EB4B64CDCD5FEC9CAF85D",
"CA51CBEEE41B05A3044290248E608E79F8418E02AFD826A432EBEBD7ABEA92E08BA84231F6EAC116F9CC27B5A8D866F2F345E51EB954735EC993D8C5B46EE7BF",
"BB8CCFB3377353B7B33C7DE5BA46E22801CA95F368CA1CDF3E5B6B6305D6EEB65C12CF530A6F4B2F1B4818FBDED9AF572914B4255BFB74B091F7952114693393",
"EA7FEBE2104A123C46FB4F5F52785B6AA40D5250F67DB6A47F377083BB92679BD4B37A28AB027F1173CACD756E81971056F94B7BE72BB65AA124B27A7C7A1BF1",
"7FD110A9E2D87F36E27E3827D6A73EC56AF73FBC6557813923A294DFE7E441528E0DD5E1DFB2239B7CA9B256136CB36571DFBE1175A2A8DFC241ABC5D451C8B4",
"9B42A4DF6AE6238B0B4A5325A4FC6B643C2923B0A40A3AACBAEFC409C7AA69CA9989D276EA57D961CD722912E8AF2F603DCB1996680CD4A8B25FBEDBD2F6C340",
"EFD33FDD8BE9F7AA7050613757D6EF1CB09C54141264F4FA74C8D465545744DAA59063D48C0F9CBA0D102390D82FF3C55458A14DC92EF5B77E3C846C54C5B782",
"9AAC6BB61A9BA8E1B107A241FBF579E5A9D47A5C19E2B6F78773E4A99B6A3AA3C64DFB3C3E5C7547F49052A7AAB89003F3313626133F58707088320D57623FF9",
"DBA9D898BDC1F48FE2E6E72F7C79B7BF2C2058CB7E50101B9C94B29AFAF0C954CF1C67A2B8405D6EF6C13187A147084B6B1BF597BF780225CAB4C9232193FAF3",
"6B5772C8E15ADEB476530F5C65CDC3E78815FDD98F8A5FAB235BB4B6DE5E9D22BE55F0A2403CA88967B7BB530899C18ABAC1EC170C558012D61447D668CF8F9A",
"E585B99774670A78B862EAE851591C59DAD457E0D64755CA8AB6E44E5DB7E48B821136497F9F9F9E8724679B486B6C2D7568362286367BFDFCE95BD4EDC83A50",
"182C8BBF953A9F1EF257A1D87641A9EB081D49B50A266E5978FE784B151AFE5B79A648F6EBE34C0FA64AB12A3FCC3A9A08E6C18672EAFEF1CC9EA362632A8C59",
"0D3875655F12C8657C50A33335BA5727DEE853EC2882BBFDFF3CDF430D3A14B8DBAEC8E710967012FC775841CDD41D5DCF9D836A2BBAE0B90F07C826DE2D32D0",
"FBF178E0BDA30CDCF62FE7B0FFF27BE849D8FFD9D5E81C935229E9EF5DB6600959D521BCDF55AB50ED98114C828C7FF1B945F0118C11109E4EC9BC665750B59F",
"91F264BC52B9CDF38B55BF6467F281FC6A486A56FF339777EE367D38008EDCC05DF77FBE6F0FC35905E5F00FCF28C7B04CB7A1DBFA37F7419656C72C5BEA1FDF",
"913ABD628336663814987D78AC2A22E5C36144DE8FAFC0DDAB12991D2079643F8B640A1430F1877C2FF96A0E638880EEA03660B12F3FDAEA16C6136D9414D6F2",
"E1345EB42938939E483D55A02A6992E95C499DAF7EDC9155B630D7D6CFB9B93FD5D82395C9A9BFF5AB67A8861A7EC48EE6F8FA41A22DE73A946B89399E3DAB8F",
"51A721C69DE5D397CA060EA3E48A12FEAD53CB8C300378B176FD743EC584C6E1371B00EBE161F2C58A4A31860246797941FEDCC46C5BB471A40FB757851AE30F",
"B34B5CECD44577D1017FC6513AA091BA3B51B0344973AAA1BFCF95A755B9019DD292E2F54144E702204E13B749DD5AD46998BE732AF3A7FB35CFCA09D86D2214",
"745E20E389B5545501AB87D9637B75C494B57580E1E8973DF55A26754986085933FBF8BD87CA9EE225A656E6E387ADE9ABFA125565E7BD6FD4B976AA5995BACE",
"93FBC68AA597A4144978F5D4ECF7D981B401B8EC8BB6C71B5F47687A547843249D3A55C1EB50C8803B01161E7EE6C77A534C6753663C5ED1790A8C0310D42C3B",
"31F387574D5DCD73190EEACC95FA0A1C6CCA66AA76B6F5FCF20226DF1517A9E5C2F7DFF795B6D8F0718E8AA471330EE85CC3B6F0B410CEF85915681ACB8EC326",
"2BE364B41E8550BCADD35EC97BD8E650DEE8D8930DA01F5E0A0ED960C501395591F338763448A37305099A759943352300A20C53BDD9F774C0A21F2B175BD33D",
"E79294287536615203F19C917CBE0CA4ADB8E549679DAEE4E206F49736BAB99FCD283865A28A0128F9B16DCD6E17539E5B9A26FB8F5371FE0EDDC7BCD977D0FC",
"0259FFA9E1336EE00B76B902F71EBBABCF5FCC095DF540B77DF8E9AF40D3784A7300CC59A7E4AF4AC81E8F949622AF87F301C8CD8EC9B6581F4F6F59792FE57B",
"6EC452BD545F7D3A635BEC256CFB75A9FF0107F7BF56A5533F25FB2C0503AAD6C43C30AA8FDC377006815EAE10EFCE799C66CF4DA16D51A77652CFD6FF1A2FB2",
"AC0A0BBFF3B2A8B01DAA3C25E76E46D4EFC3BED1753F4ABD8F9F0F9958D3EBEC7C94875B882DCE9129512309B6FBF8933FB162AF214E3933DF576FEE31CAD10D",
"05FFC92FEE228129C46835F5D87C74B5CCED488EB55EC6F9AA6021EAEB593F7D422126A8149B1648E3F1CCF86F8F0A4B9A7F39C670123F60E153F5A30F3B37E3",
"98718FCD73F5D556CB7F74080A978032E4E0D737772E43785F426AC0FEDF5CA74D778E4A7941C8B853A78D3B2E0FD08378F61FBA4D8A20830161BAAE2FBF47D7",
"9F90AD8A603E9D98F9488DED505586A77DFDFA60D4E5B7B1CE33FFF4995D7FB1B161C1D0239BFFE69E86F5ACF27CABE36E7D9FF302363D557AD8C5E16F66BD69",
"2945A8519C16B38DD98F16A82AC0C5C9DA4D7B939D2932BD8285F9A7676ED1473E1299C397566031BEBC16926231AB2DBC1AEB1FCEC508342C266E4C20BD3A8B",
"2CDA64DBD5AFF2F8173FB78F0724CA812957FD7892E6888B2D5791F478EFAB9652995997D42C9F0EDCEE1F3F8A333A8938328E29E78F295665AA4EC7BCBEFFB8",
"C125D8035E4E4A64DF59764005AB6677DAA7FB32B7C709481C959C030A89A40D15FEE396CC3BD531C91D2A50776EA71F6D83B98ECB1A256473AE36546F9648CD",
"11BC6F8E83C772E8EACC75818707940C1AEA552F8115735EA6A836B2FA6D2A56FEE6F28257AFC1E6D4201B731E567B960C64D70CAAF6335F5F326A5F072A4C87",
"65BFFC0B4E308A5CA91CE59CE5176794DD2D63811A011255F6C5AA186AFCA9A6664D3ECD711CA294933566C19B73A3571997D30D38D87CEF4BFC574D60B75B1D",
"6979FA67F3A97A3E4783AE12D7FECD4F090457312AF2DF3BFB2F5646A6417552C6FCD43FFF959BA268D3CCCEF554DBFBECE9B0C3B09E9EEDC8F66EF3FE1658FC",
"EC4A7CA23C585584F079657E545680BB373741194DFFF08C5591EDF4A581F65F3CC77909D7532A5F11F17AF6A90FC97CC4D812B1EEE9DEBB351D96536DBF48C8",
"3CFC60DBB928F2BA26C891FA5B29480DD1A31F7FFCBCBCABD3BA9ED68968F9747AA157B45DB93594933C8038DC09D363EFD922ECEB5FBB31424CE76576FFE625",
"6D3CAAFCB588982F0FF25E760FD6080DD4FCE9C45AF00C324FB2345345E6AED937770CA113EAF154BB1ED97776AA69865A42162BF50CD168725A5981574DDE46",
"35EE71D0919FA9AA0B9E5F3B4DEA7416EFDCC970D9277218559D906AD47673FE1ADC42855E9CF25502967D6D471E57888EBA4B4EDE5899C796303E2ABC1E2FED",
"7C847A0367E96CD83C7ECFB9A725067132D7D9AAEC5F6362F2AE8244D544777EF8334691ED4650909667B7723955D29AE4EF247DC667D2B4D27D1B3F4493EC53",
"ABCCBF8E3C4575B467CE71E3CB62AB6E2B5C04997953A25995FF0D7622F19B7D9CE9650635C6A3732E295075C8B8BA79F6F92F618A52CAAB161C749C37F961A3",
"AD2FFD376EDD524FE5D0E2D628469046EF1CE58DD5EB3A7E4C4D987D52718ED2D26B6E03E2263F20E16E583A8AA0DF7C5FCC9DD9262A6E658C723CFE76A92734",
"03FBBC4F3F8F2FDB51C4451D3DEEC99F879AD52074D5D996BC0740957CB5752857CE4E64FF5A11E395962BD14F78FB8C8F7B81C17076C7B6E8F30BF14CB320E9",
"C1DBA46E70C6347E930C77FA72BFFDB49AB10FB8AD0CCAFAE6446246CA3150E3E5D37D89677A2448B0BCF2829C7FB1DF3D621E07C79BDF9CB244AFBDE5E35C8F",
"913AF979F08AF228676EEFCCF3DA365AEC292A51984FE740FD28CA5B316871555A9D4F57DC0C24A6F8631278F9859C60BC2A1189477B73E5CE78CA27AABBF72E",
"8E3777DF42FDD94334670B35EF6DA8351A77D23CB6A472EE55BD6853A1B9556826CE775E386EBB90402694250E74D8441EB6CBA37E7AF22B1C3EB61395BEAC9A",
"F3A4CDA172676E1DC6BDDF3C8263CE31C914C120EDBFA83EDB065691EBEA59C7457DABF654E838BFB8E1850BC30FBA3ABA967C0E40EDD8E75D76B89FFE9CF866",
"A1650BC6F6FBFC7821FB5B4E52AC501DBDF93BEBE2AD9C090F52C43D334E7A5ADEA611BDD8D42B5A4FC993D8B0E589FB4F07FBD7479375A5E2B4396B287E7510",
"67A8CCC3CB525A7D3A64E3ED74A8A4B00506BAFBFCC287F7F3A3CA95FA671F4AD8B34A94BFA4DAC403B89A11BB29EA3837FB5036406250ECC6A4577FF5B8D5D8",
"F5C6173CC95A2279E040926214A98FAF1FA11C2FA49B06C05192275F2A379AEDD61D95E1D79FBD762A4F0CA1DCA723ADD665C74E9336E16440E24C8590C5C17D",
"C5B9F73F7DDE2A25AE088714F4E9510925CAD8AEACA9D4E2D3A537819240076358E5CB3BD63B37D8FC19F71FE47C6BE82E7CB44440A9CFDFA770B7CAEA8414A7",
"67FC9CDE886287176BB8EFDE0CE78386A659ED3A8B019267DB71EB4AD0BEDA58FD740E217B57C06D6DF6EEF10891555564C16BD5F1E9246530BA826C6F8FF9FA",
"C8FAE08AE14211744DFD83AC77F427142C0A07733E4EC43D9DF29DC109276FBFD5FF7427F57BE279E7059C16DAC6FEA6E3A7DE6C5A0EDA3872987E675F465B70",
"14DAF1A196BC9F7AF25087788DCDF8FABCEA94B02595E98220E265EA51AD40B15BE719ED3396A8D7CCA7F34605E1A0ECF9FA68EAC744DBDE4E63EBF5F58F8E41",
"BEC46C137FA9E4BC8F7D761BDBC6BEB889E7D949C8EDA2212110BC3D71A0FD2FD515C37ED96989DF9C18B27B1585777DF1DCD75558AD14A4FDF41881B7BD3C64",
"AA3A707277DDD4AD79A1430CBED800EAFBE155D9B7EA309007BC77F2AB2B0A54AF3E88F1E0357FF5EC74FEF4C4A540A2F773F2FE8AA972E1C614E5DEA9BB63C7",
"77E8F085B379FF8CFAA82BF81717698D3DF18FB3514AC01DE320FEACD4BF19BEFEEAA35EDE1CC1769ECEA673312E5A637EFCA77D7F871A54039FE4CF63BAB878",
"29C13AE19B799F52746A249BEDFD7F3CC38DE117AB7EB364F63D2DA09DA05C2BDA51DFFD4BAAE5EC95891EEB9B5BF1DEA41510C55E1F0134F913EF65BA8441E7",
"38C5F3396FDB7BFFF11B238A92AF4FAA3048BDAE05FB37776052D9B2D9C781F6F9F6276E17D07BBD5B277580CE2D8EB8A2C1A25F2175CE599718E13BA19B2B25",
"FB8931D750825D6AAAEE732E4637126CEF285F937712A856D5C06EE07F74B3C1AEC58C97829EA7D31BE24CA1083941F5E3CCFEFEB6172074D68B9D357EFA8D6E",
"BF4F75CA8AE9B095FDA910C47B010767334AE24FF16E5505E4F4E6CE39ACB86A47E6F9DACF2AE5F121D751ED61CD6763B7273F5F151B3445910A37E72EC987DF",
"A88A25E30D8CDF3D1BD38698341B71EFE9216FCC63AA3E9194884AFBF9D18AEA3A464D419CE7F169CDA6AD8A6B61CE9AC9CF4735E20D01B1CF4F3F70BCDF43F5",
"8F63F68E36243F2C5D1033A34766FCE95D8FF702392352434AAD7A2DE756ACF31D1770027BE51C810D7F8373B1BDA32221F59F35E070A9211B4F5E54BEC293E7",
"00EC06263FA3B4D93CCEF9AA643D2FCECB6DAF41F1A8D0C16991BC778B74248DEDC56AD844DE9B41128AFB0D1C92BBF7D75F904FE6E151FC3ADFB16FD6D176B8",
"0C414D31C8FD741A6A6DDC027B56F5E9E49D3B883225EE4F508BDFB34FE1254DCA3104573379FEAE16484DA1D5A997673CFBD9E6A92A53779C92CB730C633D55",
"F1ED9A6FCEBAAB8F75B2D98BB18427FDD52F6CE192D73A0E4FB0E69BF3C5435472BD5066B596F7B4483E86855AB47A6151CE41380B6EFBD76E6EEF79EE75D887",
"E3E14EA8EE9C939DCE593990E1CC767BFC4FFB17537A1873B17AB2F27C795FEE440D9F59419620F9DE1BED3CEB62AF917879CACB40D88ABFB16AAF94C93E820D",
"7902CF09DAF1D3A92E8726A463C1C240BBD4E9D9368DC695BA8CBFFBBE229E8BBFABC2072BE192BC598F7BAF7ADCC71524D3777F4E512DBAAC5FE7EB9B6CE7C1",
"D90A27AC83B5C939A3A302BC472D6ECBEB66DFCD8989E515254E1B3EDE8FF3FA1BF32D319BB4C6D747508C2B9054C335EFF874535E5E109AFE1D12AAD4057154",
"4AB27D6135883FBCD79DB295775041DCBF39E5E62CA62250A78BED1E66BF6C2A91752E86B4DFB31F5DBC1DEA6F42C5F18095BCBD23B58E89D8B6ED3BE774BCB1",
"EDEF968D1EF7B2BC7AF03E8EC179A6D4F33BBF69392947E66C55195FDD6ADDA7F33954541327BB6F5BFD8033BED9175EEA4C541BC795132BEFEB30BE397E221B",
"A395D7F2FCD7E64B0FAA5638B3328F387B14350331C6FB6F72FE57A91FC6704458FBE94C88F3CEA43A4F14A5DC6CA96770C8AAC46538DECAD447E213050D25C6",
"DAC74F3F16CFE75D4283D303617DFDDF1EE3C3B6F625FF5277EA9D7E5E3510E253B989F77D6BD8F1BBB970CED463C8DF4A453A1468684ADD2969D66922A56BCE",
"C9E673702A2723A4E1C9892BE7078B05B1DF94ACDAA9F75371217F655CFDFA53CE59A8B6513AA2C0E2BB87EAC6258CDD0EA15DBF96FA16EF9D5832C3BF61ACFF",
"E81F64BEBD27CD934FBDA2E85C6944933BEED9178EF53585F921C7DC0F6F4F791FC055952B741223FDE80FE1B24B46C39AFE2805836B6F6753CA77CF00DF948A",
"5297E255243B79451BB371E99DF3B85FBEB6E0B37DA72A4CEE627E73E8863B5538DE0836CF2F4F6D36344A1ADB14EBC3755EABA96EC4904599B4D3AFEF8A8B2C",
"6D9BC9AC649F822279C7C5522B5AEDAFBEDED1EF14F8D4F09B96F7272C091B11E98A5B225F5FCC692B15DD4D867865BF29448D4E37F12BB6E1F31E39163EE272",
"546FDE3A2DEF5B90D51012797F9B0546C68DB8F8A7A8068E49CEBC17D151046F1AD9CE1B9EEC2FD84DB439631590BCB1F782D6106E12469B1D8FB71E8937A979",
"D39BD7023EFC46AA744A23EE42B839DFE11C9F84BE68CF81A6EF9EB4AA282A2E7255245F66493ECA66760B38D3C7D7A72E7F6D4F6F115A5E01F19E1FE95AFAB0",
"79C1C8E3E79DB3EE31D966BB43A1E7FACECB411C55C84BC9E4F8F49CC6EC15C84E6DE4776FAD6A00AB7A4B988CE757D2C1A05E1CE47EF7D1590FCA5B910B5571",
"651FCD7E9669DAA65C11F0978CAB0EEF538C5A067BC965CB7B1DBD81564641AEF6CD21D6B82F714959D846F3A29B9CA3513AAC1E46F1E4ED6FFEC5DF53902BFE",
"92B9CFFD77E455299724B023088FD76A33269F04B926D0AF5FD3A220F8136A7C7590F78358D2A88792CE4CBDF1AE7183A2CA8E7D3F3B51DDF077F36BF756C3EC",
"E3289194B9B567EEFD70793FDB328A8DB8C131AE827BF79944F9A99642A45CF7AB1F5BFC63F4738D1EE3D365C93F7AD9830567BFE5ABEF66E87FE256879EF15F",
"88EDFE0FC98CF678C8C09F0A939DA9950B5B394720976C8577E276C7FFDC0B2A38B831D6E9852D8F679031E009F2B1F27E797FD4899A0FA4A4CAE23CDEDE3908",
"5514312574432B99F58E7ABB2AA33B9D5478BC6289BB3DBC72BA5B1D270EB45120A110B7D2D99DC97812F25795A1760C9247F252B512C26A19AEA793B41EF78E",
"43053D52CDAD7E3AF9A9EAD3B145AF20CAFB70C07B01AB43F4E210C8AB5F8884EA41492D910BB30E8AA695807138899BF71AD96CBBCEE7487AF537EFD0AC770C",
"02723D2B6E40C87BF0829CB4588FEB6F9337E065CCFAD57B48B0E09EF762796BD1F40632B721E72829285768014FCCA964FFEE90D2AAF9B17A77C0BB47287827",
"BB4CDE75A23C3CF16A741F39BE2B785C4F3FE95C408B11413942075D53071297F5A82467174ACF7BA5E21600858D3718829CA31745C944C6EC4ECE93CACF28B5",
"948291059ADFFD2D5EA8613F5B5070DEBDD9EEDB2C31962D074D88CD7B029544B04EAF9C537A70B3EFA08BDA250F9DF87FE6989660CC812BF9F09DF723A9FB35",
"DF29E4F226CB97076D1E7B69968DCF5E52E72FE96101E735C4B2E5595F8C182BEF524E82F1BCE7F0DABD31599B3B67EA55BC856E0898FE68893FFFFA7FA2AA55",
"03" };


void testAR()
	{
	std::string filename("testar.txt");
	MT2004_64 gen(1);
	size_t N = 1000;

	double * tab = new double[N];

	for (size_t i = 0; i < N; i++)
		{
		tab[i] = Unif(gen);
		}
	cout << "DONE 1\n";

	
	std::string asr;

	
	{
	OCPPArchive oar("blop");
	for (size_t i = 0; i < N; i++)
		{
		oar & tab[i];
		}
	cout << "------\n" << oar.get();
	}
	
	

	{
	double * tab2 = new double[N];
	cout << "DONE 3\n";

	ICPPArchive iar(blop);
	for (size_t i = 0; i < N + 1 ; i++)
		{
		iar & tab2[i];
		}
	cout << "DONE 3\n";


	for (size_t i = 0; i < N; i++)
		{
		if (tab[i] != tab2[i]) { cout << "ERROR :" << i << "\n"; }
		}
	cout << "DONE 4\n";
	}

	}



int main(int argc, char *argv[])
	{

	MTOOLS_SWAP_THREADS(argc, argv);
	parseCommandLine(argc, argv);

	testAR();
	cout.getKey();
	cout.getKey();
	return 0;

	{
	OFileArchive ar("bou.txt");
	ar << "CEci est un test.";
	int64 r = 123456998;
	ar & r & std::string("Hello World\n");
	std::map<int, double> mm;
	ar & mm;
	ar & nullptr;

	//cout << ar.get() << "\n";
	//cout.getKey();
	//return 0;
	}
	{
	IFileArchive ir("bou.txt");
	std::string s;
	int64 v = 7;
	ir & v;
	ir & s;
	cout << v << "\n";
	cout << s << "\n";
	cout.getKey();
	return 0;
	}

	auto P1 = makePlot2DPixel(getColor, 2);
	auto P2 = makePlot2DLattice(getColor2);

	Plotter2D plotter;

	plotter[P1];
	plotter[P2];

	plotter.range().setRange(fBox2(-500, 500, -300, 300));
	plotter.plot();


	return 0;
	cout.getKey();

	RStarTree<int, 2> RST;

	RST.make();

	cout << RST.toString(true) << "\n";

	cout.getKey();

	/*
	Img<unsigned char> im; 
	im.load("lenna.jpg");

	Plotter2D plotter;


	auto P3 = makePlot2DCImg(nullptr, 6,"image");

	plotter[P3];

	plotter.startPlot(); 

	cout.getKey();

	P3.image(im);

	cout.getKey();

	P3.image(nullptr);
	
	cout.getKey();
	
	P3.image(im);

	cout.getKey();

	plotter.endPlot();

	return 0;

	auto P1 = makePlot2DLattice(color, "Lattice");
	auto P2 = makePlot2DPixel(color, 6, "Pixel");

	plotter[P1][P2];
	plotter.plot();
	return 0;
	*/


    }

/* end of file main.cpp */






